<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple GLB Loader</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background-color: #6b3e07;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-family: monospace;
            z-index: 100;
        }
        
        /* CSS to help with color debug */
        .debug-box {
            position: fixed;
            bottom: 10px;
            left: 10px;
            width: 50px;
            height: 50px;
            background-color: #000000;
            border: 1px solid white;
        }
    </style>
</head>
<body>
    <div id="info">Loading model...</div>
    <div class="debug-box"></div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <script>
        // Simple Three.js setup
        let scene, camera, renderer, controls;
        let mixer, clock;
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6b3e07);
            
            // Setup camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 3);
            
            // Create renderer with proper color space
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);
            
            // Setup lighting for proper 3D appearance
            // Strong ambient light for base illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
            scene.add(ambientLight);
            
            // Add multiple directional lights for even illumination
            const directionalLights = [
                new THREE.DirectionalLight(0xffffff, 0.5),
                new THREE.DirectionalLight(0xffffff, 0.5),
                new THREE.DirectionalLight(0xffffff, 0.5),
                new THREE.DirectionalLight(0xffffff, 0.5)
            ];
            
            // Position lights around the model
            directionalLights[0].position.set(1, 1, 1);
            directionalLights[1].position.set(-1, 1, 1);
            directionalLights[2].position.set(1, -1, -1);
            directionalLights[3].position.set(-1, -1, -1);
            
            // Add lights to the scene
            directionalLights.forEach(light => scene.add(light));
            
            // Setup orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.update();
            
            // Initialize animation clock
            clock = new THREE.Clock();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Setup mouse tracking for interactive rotation
            document.addEventListener('mousemove', onMouseMove);
            
            // Load GLB model
            loadModel();
        }
        
        // Mouse position tracking
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        
        function onMouseMove(event) {
            // Calculate normalized mouse position (-1 to 1)
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Convert to target rotation (subtle effect)
            targetRotationY = mouseX * 0.6;
            targetRotationX = mouseY * 0.3;
        }
        
        function loadModel() {
            const infoDiv = document.getElementById('info');
            infoDiv.textContent = 'Loading model...';

            // Initialize the GLTFLoader
            const loader = new THREE.GLTFLoader();

            // Initialize and set up DRACOLoader
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            loader.setDRACOLoader(dracoLoader);

            // Load the model
            loader.load(
                'models/ExploRa.glb',
                
                // onLoad callback
                function(gltf) {
                    infoDiv.textContent = 'Model loaded!';
                    
                    // Completely clear the scene of any previous models
                    for (let i = scene.children.length - 1; i >= 5; i--) {
                        scene.remove(scene.children[i]);
                    }
                    
                    const model = gltf.scene;
                    
                    // Use a material that properly reflects light to show 3D structure
                    model.traverse(function(child) {
                        if (child.isMesh) {
                            // Use Standard material that responds to lighting
                            const newMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x222222,      // Very dark grey
                                roughness: 0.5,       // Medium roughness for some reflection
                                metalness: 0.4,       // Slight metallic look
                                emissive: 0x000000,   // No self-illumination
                                flatShading: false,   // Smooth shading
                                wireframe: false
                            });
                            child.material = newMaterial;
                        }
                    });
                    
                    // Center the model's pivot
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.sub(center); // Move model to origin
                    const pivot = new THREE.Group();
                    pivot.add(model);
                    scene.add(pivot);
                    
                    // Apply scale before adding to scene to prevent distortion
                    pivot.scale.set(0.3, 0.3, 0.3);
                    // Place at exact center 
                    pivot.position.set(-0.5, 0, 0); // Moved slightly to the left
                    
                    // Adjust controls to focus on the pivot
                    controls.target.copy(pivot.position);
                    controls.update();
                    
                    // Fixed camera and controls
                    camera.position.set(0, 0, 2);
                    controls.update();
                    
                    // Hide info after loading
                    setTimeout(() => {
                        infoDiv.style.display = 'none';
                    }, 2000);
                },
                
                // onProgress callback
                function(xhr) {
                    if (xhr.lengthComputable) {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(1);
                        infoDiv.textContent = `Loading: ${percent}%`;
                    }
                },
                
                // onError callback
                function(error) {
                    infoDiv.textContent = 'Error loading model';
                    infoDiv.style.color = '#ff5555';
                    
                    // Try loading without DRACO as fallback
                    loader.setDRACOLoader(null);
                    loader.load('models/ExploRa.glb', 
                        function(gltf) {
                            infoDiv.textContent = 'Model loaded (without DRACO)!';
                            const model = gltf.scene;
                            scene.add(model);
                        },
                        undefined,
                        function() {
                            infoDiv.textContent = 'Failed to load model';
                        }
                    );
                }
            );
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001; // Get time in seconds
            
            // Get the model (if loaded)
            if (scene.children.length > 5) { // Skip the lights
                const model = scene.children[5];
                
                // Base auto-rotation that continues even without mouse movement
                const autoRotationSpeed = 0.2;
                const autoRotationY = Math.sin(time * 0.5) * 0.1;
                const autoRotationX = Math.cos(time * 0.3) * 0.05;
                
                // Combine auto-rotation with mouse-based rotation
                // Apply smooth interpolation for natural movement
                model.rotation.y += (targetRotationY + autoRotationY - model.rotation.y) * 0.05;
                model.rotation.x += (targetRotationX + autoRotationX - model.rotation.x) * 0.05;
                
                // Add a gentle hovering effect
                model.position.y = Math.sin(time) * 0.03;
            }
            
            // Update controls and render
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize and start animation loop
        init();
        animate();
    </script>
</body>
</html>